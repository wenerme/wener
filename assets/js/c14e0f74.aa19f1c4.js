"use strict";(self.webpackChunkwener_website=self.webpackChunkwener_website||[]).push([["49486"],{758948:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>s,toc:()=>c,default:()=>p,metadata:()=>t,assets:()=>l,contentTitle:()=>o});var t=JSON.parse('{"id":"java/lib/calcite","title":"Apache Calcite","description":"- apache/calcite","source":"@site/../notes/java/lib/calcite.md","sourceDirName":"java/lib","slug":"/java/lib/calcite","permalink":"/notes/java/lib/calcite","draft":false,"unlisted":false,"editUrl":"https://github.com/wenerme/wener/edit/master/notes/../notes/java/lib/calcite.md","tags":[],"version":"current","lastUpdatedBy":"wener","lastUpdatedAt":1767451770000,"frontMatter":{"title":"Apache Calcite"},"sidebar":"docs","previous":{"title":"arthas","permalink":"/notes/java/lib/arthas"},"next":{"title":"CHANGELOG","permalink":"/notes/java/lib/changes"}}'),i=a(486106),r=a(917776);let s={title:"Apache Calcite"},o,l={},c=[{value:"Tips",id:"tips",level:2}];function d(e){let n={a:"a",h2:"h2",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/apache/calcite",children:"apache/calcite"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Apache-2.0, Java, SQL"}),"\n",(0,i.jsx)(n.li,{children:"A dynamic data management framework and SQL parser/optimizer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://dl.acm.org/citation.cfm?id=3190662",children:"https://dl.acm.org/citation.cfm?id=3190662"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/1802.10233",children:"https://arxiv.org/abs/1802.10233"}),"\n",(0,i.jsx)(n.a,{href:"https://arxiv.org/pdf/1802.10233.pdf",children:"https://arxiv.org/pdf/1802.10233.pdf"})]}),"\n",(0,i.jsx)(n.p,{children:"Orca [45] is a modular query optimizer used in data management\nproducts such as Greenplum and HAWQ. Orca decouples\nthe optimizer from the query execution engine by implementing a\nframework for exchanging information between the two known as\nData eXchange Language. Orca also provides tools for verifying the\ncorrectness and performance of generated query plans. In contrast\nto Orca, Calcite can be used as a standalone query execution engine\nthat federates multiple storage and processing backends, including\npluggable planners, and optimizers."}),"\n",(0,i.jsx)(n.p,{children:"Spark SQL [3] extends Apache Spark to support SQL query execution\nwhich can also execute queries over multiple data sources\nas in Calcite. However, although the Catalyst optimizer in Spark\nSQL also attempts to minimize query execution cost, it lacks the\ndynamic programming approach used by Calcite and risks falling\ninto local minima."}),"\n",(0,i.jsx)(n.p,{children:"Algebricks [6] is a query compiler architecture that provides\na data model agnostic algebraic layer and compiler framework\nfor big data query processing. High-level languages are compiled\nto Algebricks logical algebra. Algebricks then generates an optimized\njob targeting the Hyracks parallel processing backend. While\nCalcite shares a modular approach with Algebricks, Calcite also\nincludes a support for cost-based optimizations. In the current\nversion of Calcite, the query optimizer architecture uses dynamic\nprogramming-based planning based on Volcano [20] with extensions\nfor multi-stage optimizations as in Orca [45]. Though in principle\nAlgebricks could support multiple processing backends (e.g.,\nApache Tez, Spark), Calcite has provided well-tested support for\ndiverse backends for many years."}),"\n",(0,i.jsx)(n.p,{children:"Garlic [7] is a heterogeneous data management system which\nrepresents data from multiple systems under a unified object model.\nHowever, Garlic does not support query optimization across different\nsystems and relies on each system to optimize its own queries."}),"\n",(0,i.jsx)(n.p,{children:"FORWARD [17] is a federated query processor that implements\na superset of SQL called SQL++ [38]. SQL++ has a semi-structured\ndata model that integrate both JSON and relational data models\nwhereas Calcite supports semi-structured data models by representing\nthem in the relational data model during query planning.\nFORWARD decomposes federated queries written in SQL++ into\nsubqueries and executes them on the underlying databases according\nto the query plan. The merging of data happens inside the\nFORWARD engine."}),"\n",(0,i.jsx)(n.p,{children:"Another federated data storage and processing system is BigDAWG,\nwhich abstracts a wide spectrum of data models including\nrelational, time-series and streaming. The unit of abstraction in\nBigDAWG is called an island of information. Each island of information\nhas a query language, data model and connects to one or more\nstorage systems. Cross storage system querying is supported within\nthe boundaries of a single island of information. Calcite instead\nprovides a unifying relational abstraction which allows querying\nacross backends with different data models."}),"\n",(0,i.jsx)(n.p,{children:"Myria is a general-purpose engine for big data analytics, with\nadvanced support for the Python language [21]. It produces query\nplans for other backend engines such as Spark and PostgreSQL."}),"\n",(0,i.jsx)(n.p,{children:"a query parser and validator that can\ntranslate a SQL query to a tree of relational operators"}),"\n",(0,i.jsx)(n.p,{children:"optimized SQL"}),"\n",(0,i.jsx)(n.p,{children:"Relational algebra"}),"\n",(0,i.jsx)(n.p,{children:"Operators"}),"\n",(0,i.jsx)(n.p,{children:"DML filter, project, join, window"}),"\n",(0,i.jsx)(n.p,{children:"Traits\ndoes not use different entities to represent logical\nand physical operators."}),"\n",(0,i.jsx)(n.p,{children:"describes the physical properties\nassociated with an operator using traits."}),"\n",(0,i.jsx)(n.p,{children:"s help the optimizer\nevaluate the cost of different alternative plans. Changing a\ntrait value does not change the logical expression being evaluated"}),"\n",(0,i.jsx)(n.p,{children:"tries to enforce certain traits on\nrelational expressions,"}),"\n",(0,i.jsx)(n.p,{children:"sort order of certain columns. Relational\noperators can implement a converter interface that indicates\nhow to convert traits of an expression from one value to another"}),"\n",(0,i.jsx)(n.p,{children:"common traits that describe the physical properties\nof the data produced by a relational expression, such as ordering,\ngrouping, and partitioning."}),"\n",(0,i.jsx)(n.p,{children:", one of the main features of Calcite\nis the calling convention trait."}),"\n",(0,i.jsx)(n.p,{children:"adapter is an architectural pattern that defines how Calcite\nincorporates diverse data sources for general access."}),"\n",(0,i.jsx)(n.p,{children:"Calcite uses a physical trait known\nas the calling convention to identify relational operators which correspond\nto a specific database backend."}),"\n",(0,i.jsx)(n.p,{children:"adapters is a powerful abstraction that enables not\nonly optimization of queries for a specific backend, but also across\nmultiple backends. Calcite is able to answer queries involving tables\nacross multiple backends by pushing down all possible logic to each\nbackend and then performing joins and aggregations on the resulting\ndata"}),"\n",(0,i.jsx)(n.p,{children:"includes a set of planner rules to transform\nexpression trees."}),"\n",(0,i.jsx)(n.p,{children:"Metadata providers. Metadata is an important part of Calcite\u2019s\noptimizer, and it serves two main purposes: (i) guiding the planner\ntowards the goal of reducing the cost of the overall query plan, and\n(ii) providing information to the rules while they are being applied."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://janino-compiler.github.io/janino/",children:"https://janino-compiler.github.io/janino/"})}),"\n",(0,i.jsx)(n.p,{children:"metadata providers are pluggable, they are compiled and\ninstantiated at runtime using Janino"}),"\n",(0,i.jsx)(n.p,{children:"Planner engines. The main goal of a planner engine is to trigger\nthe rules provided to the engine until it reaches a given objective. At\nthe moment, Calcite provides two different engines. New engines\nare pluggable in the framework.\nThe first one, a cost-based planner engine, triggers the input rules\nwith the goal of reducing the overall expression cost. The engine\nuses a dynamic programming algorithm, similar to Volcano [20],\nto create and track different alternative plans created by firing the"}),"\n",(0,i.jsx)(n.p,{children:"Materialized views. One of the most powerful techniques to accelerate\nquery processing in data warehouses is the precomputation of\nrelevant summaries or materialized views"}),"\n",(0,i.jsx)(n.p,{children:"The first approach is based on view substitution [10, 18]. The aim\nis to substitute part of the relational algebra tree with an equivalent\nexpression which makes use of a materialized view, and the\nalgorithm proceeds as follows: (i) the scan operator over the materialized\nview and the materialized view definition plan are registered\nwith the planner, and (ii) transformation rules that try to unify\nexpressions in the plan are triggered."}),"\n",(0,i.jsx)(n.p,{children:"The second approach is based on lattices [22]. Once the data\nsources are declared to form a lattice, Calcite represents each of\nthe materializations as a tile which in turn can be used by the optimizer\nto answer incoming queries. On the one hand, the rewriting\nalgorithm is especially efficient in matching expressions over data\nsources organized in a star schema, which are common in OLAP\napplications. On the other hand, it is more restrictive than view\nsubstitution, as it imposes restrictions on the underlying schema."}),"\n",(0,i.jsx)(n.p,{children:"Calcite as its rule and cost-based optimizer. Instead of relying on\nCalcite\u2019s JDBC driver, SQL parser and validatorHive uses its own\nimplementation of these components. The query is then translated\ninto Calcite operators, which after optimization are translated into\nHive\u2019s physical algebra. Hive operators can be executed by multiple\nengines, the most popular being Apache Tez [43, 51] and Apache\nSpark ["}),"\n",(0,i.jsx)(n.p,{children:"Apache Apex\u2122\nEnterprise-grade unified stream and batch processing engine."}),"\n",(0,i.jsx)(n.p,{children:"Now with event-time windowing and high-level API."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.cascading.org/projects/lingual/",children:"https://www.cascading.org/projects/lingual/"})}),"\n",(0,i.jsx)(n.p,{children:"ANSI SQL on Cascading"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/omnisci/mapd-core",children:"https://github.com/omnisci/mapd-core"})})]})}function p(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},917776:function(e,n,a){a.d(n,{R:()=>s,x:()=>o});var t=a(7378);let i={},r=t.createContext(i);function s(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);