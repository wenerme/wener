---
slug: regex-note
title: Regex 速记
tags:
- 笔记
date: 2013-10-13
---

Regex 速记
==========

> 需要注意的是, 由于正则在不同的流派中表示有所不同,只能整理一些几乎雷同的.
> 不同流派之间的差异,很多在是否需要转义上,例如 在有些流派里 `()` 要写成 `\(\)`
> 这里整理的主要是 PCRE 流派的正则语法

<!-- more -->

字符表示
--------

字符缩进表示
: `\n,\t,\a,\b,\e,\f,\r,\v`

八进制转义
: `\num`

十六进制转义/Unicode 转义
: `\xnum,\x{num},\unum,\Unum`

控制字符
: `\cchar`

字符及相关结构
---------------

普通字符组
: `[a-z].[^a-z]`

几乎能匹配任何字符的元字符
: `.`

单个字节
: '\C'

Unicode 组合字符序列
: `\X`

字符组简记(大写为排除)
: `\w,\W,\s,\S,\d,\D`

Unicode 属性区域和分类
: `\p{prop},\P{prop}`

POSIX "字符组"方括号表示
: `[[:alpha:]]`

POSIX "Collating序列" 方括号表示
: `[[.span.-11.]]`

POSIX "字符等价类" 方括号表示
: `[[=n=]]`

锚点及其他 "零长度断言"
-----------------------

行/字符串起点
: `^, \A`

行/字符串终点
: '$. \Z, \z'

本次匹配的开始位置/上次匹配的结束位置
: `\G`

单词分界符
: `\b,\B,\<,\>`

顺序环视
: `(?=...), (?!...)`

逆序环视
: `(?<=...),(?<!...)`

注释和模式修饰词
----------------

模式修饰词
: `(?modifier),(-?modifier)`
: eg:`(?i)...(?-i)`

模式作用范围
: `(?modifier:...)`
: eg:`(?i:....)`

注释
: `(?#...),#...`

文本范围
: `\Q,\E`

分组,捕获,条件判断和控制
------------------------

捕获/分组
: `(...),\1,\2`

仅用于分组
: `(?:...)`

命名捕获
: `(?<name>...)`

固化分组
: `(?>...)`

多选
: `...|...|...`

条件判断
: `(?if then|else)`

匹配优先量词
: `*,+,?,{m,n}`

忽略优先量词
: `*?,+?,??,{m,n}?`

占有优先量词
: `*?,++,?+,{m,n}+`

命名字符组
----------

关于这些字符组的命名,可以参考[susv-ctype].需要注意的是,在unicode里,这些字符组的定义要根据unicode 的定义来判断.会包含额外的同义的字符.

组|描述
-:|:-
[:alnum:]|
[:alpha:]| 字母
[:blank:]| 空白
[:cntrl:]| 控制符
[:digit:]|
[:graph:]| 可显示
[:lower:]| 小写
[:upper:]| 大写
[:space:]| 包括 [:blank:], 换行, 回车及其他

测试引擎类型
------------

`nfa|nfa.not` 匹配 `nfa.not`

匹配结果 | 说明
-|-
nfa|传统 NFA
nfa.not|POSIX / DFA

DFA 不支持捕获型括号和回溯

`x(.+)+x` 匹配 `=xx============================================================`

匹配结果 | 说明
-|-
时间长|NFA
时间短|DFA, 但也有可能是混合的或优化的

引擎|工具
-|-
DFA | awk, egrep, flex, lex, MySQL, Procmail
Tranditional NFA | GNU Emacs, Java, grep, less, more, .NET, PCRE, Perl, PHP, Python, Vi, Ruby, sed
POSIX NFA| mawk, Mortricekern System;s utiles, GNU Emacs
DFA/NFA | GNU awk, GNU grep, Tcl

匹配基础
--------

规则1
: 优先选择最左端的匹配结果

规则2
: 标准量词是匹配优先的

NFA
: 表达式主导

DFA
: 文本主导,不关心表达式的形式
: 即 `x*=x?x?...=(x(x(x...)?)?)?`

匹配优先量词和忽略优先量词控制,对回溯状态选择,是跳过还是进行.

环视模拟固化分组
: `(?>...) => (?=(...))\1`

多选结构即非匹配优先,也非忽略优先,而是顺序优先
: eg: `(to|tow) =~ "tow" = "to"`




<!-- 链接 -->
[susv-ctype]:http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/ctype.h.html
